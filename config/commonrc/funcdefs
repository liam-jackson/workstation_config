#!/usr/bin/bash
# echo "entered funcdefs"

# To use custom commands instead of find, override _fzf_compgen_{path,dir}
_fzf_compgen_path() {
	eza --all --all --oneline --color=always --icons always "$1" 2>/dev/null
}

_fzf_compgen_dir() {
	eza --all --all --only-dirs --oneline --color=always --icons always "$1" 2>/dev/null
}

# fh - repeat history
fh() {
	print -z $( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s --tac | sed -E 's/ *[0-9]*\*? *//' | sed -E 's/\\/\\\\/g')
}

# bathelp is an alias in config/commonrc/aliases
help() {
	"$@" --help 2>&1 | bathelp
}

# Shows the keybinds/the widgets they trigger that you might've
# collected from the debug functions in .zshrc:
fkbd1() {
	local _help _filter _keybinds_and_widgets _selected_keybind _sort_by_keybind _sort_by_widget _filter_label

	_help='Interactively browse the keybinds and widgets they trigger using fzf.

	Usage:
		fkbd [-f|--filter=binds|widgets] [-b|binds] [-w|--widgets] [-h|--help]

		-f, --filter=binds|widgets	filter by keybind/widget.
		-b, --binds	filter by keybind (shortcut for --filter=binds).
		-w, --widgets	filter by widget (shortcut for --filter=widgets).
		-h, --help	show this help message.
	'
	_filter='binds'

	if $# -gt 0; then
		case "${1}" in
		"-f" | "--filter")
			_filter=$2
			shift 2
			;;
		"-b" | "--binds")
			_filter="binds"
			shift
			;;
		"-w" | "--widgets")
			_filter="widgets"
			shift
			;;
		"-h" | "--help")
			echo "${_help}"
			return 0
			;;
		*)
			echo "Unknown usage."
			echo "${_help}"
			return 1
			;;
		esac
	fi

	_keybinds_and_widgets=$(mktemp)

	function _get_keybinds_and_widgets() {
		bindkey | sort -k"$([[ "${_filter}" =~ "bind" ]] && echo '1' || echo '2')" | awk '{print $1 " " $2}' >"${_keybinds_and_widgets}"

		awk '{print $1}' <"${_keybinds_and_widgets}"
	}

	_sort_by_keybind='_filter=binds; _get_keybinds_and_widgets'
	_sort_by_widget='_filter=widgets; _get_keybinds_and_widgets'
	_filter_label="$([[ "${_filter}" =~ "bind" ]] && echo "Keybind" || echo "Widget") for selected $(echo "${_filter}" | tr 'a-z' 'A-Z'):"
	_selected=$(
		fzf \
			--bind "start:reload(_get_keybinds_and_widgets)"
		# --preview "grep --fixed-strings {} ${_keybinds_and_widgets} | awk '{\$1=\"\"; 'print' \$0}'" \
		# --preview-window 'right,border-top,<72(down,border-top)' \
		# --preview-label="${_filter_label}" \
		# --preview-label-pos '0:top' \
		# --bind 'ctrl-w:reload(_sort_by_widget)' \
		# --bind 'ctrl-b:reload(_sort_by_keybind)'
	)

	/bin/rm -f "${_keybinds_and_widgets}"

	if [[ -n "${_selected}" ]]; then
		echo "Selected $([[ "${_filter}" =~ "bind" ]] && echo "keybind" || echo "widget"): ${_selected}"
	fi
}
fkbd2() {
	local _help _filter _keybinds_and_widgets _selected _sort_by_keybind _sort_by_widget _filter_label

	_help='Interactively browse the keybinds and widgets they trigger using fzf.

	Usage:
		fkbd [-f|--filter=binds|widgets] [-b|binds] [-w|--widgets] [-h|--help]

		-f, --filter=binds|widgets	filter by keybind/widget.
		-b, --binds	filter by keybind (shortcut for --filter=binds).
		-w, --widgets	filter by widget (shortcut for --filter=widgets).
		-h, --help	show this help message.
	'
	_filter='binds'

	while [[ "$#" -gt 0 ]]; do
		case "${1}" in
		"-f" | "--filter")
			_filter=$2
			shift 2
			;;
		"-b" | "--binds")
			_filter="binds"
			shift
			;;
		"-w" | "--widgets")
			_filter="widgets"
			shift
			;;
		"-h" | "--help")
			echo "${_help}"
			return 0
			;;
		*)
			echo "Unknown usage."
			echo "${_help}"
			return 1
			;;
		esac
	done

	_keybinds_and_widgets=$(mktemp)
	bindkey | sort -k"$([[ "${_filter}" == "binds" ]] && echo '1' || echo '2')" | awk '{print $1 " " $2}' >"${_keybinds_and_widgets}"

	# You need to prepopulate your data before calling fzf and then directly work on that data
	_selected=$(fzf \
		--preview "grep --fixed-strings {} ${_keybinds_and_widgets} | awk '{\$1=\"\"; 'print' \$0}'" \
		--preview-window 'right,border-top,<72(down,border-top)' \
		--preview-label="${_filter_label}" \
		--preview-label-pos '0:top' \
		--bind 'ctrl-w:reload(_sort_by_widget)' \
		--bind 'ctrl-b:reload(_sort_by_keybind)' \
		--prompt="Select a ${_filter}: " <"${_keybinds_and_widgets}")

	/bin/rm -f "${_keybinds_and_widgets}"

	if [[ -n "${_selected}" ]]; then
		echo "Selected $([[ "${_filter}" =~ "bind" ]] && echo "keybind" || echo "widget"): ${_selected}"
	fi
}

fkbd() {
	local _help _keybinds_and_widgets _selected

	_help="Interactively browse the keybinds and widgets they trigger using fzf.

		Usage:
			fkbd [-f|--filter=[binds,widgets]] [-b|--binds] [-w|--widgets] [-h|--help]

			-f, --filter=[binds|widgets]  filter by keybind/widget.
			-b, --binds filter by keybind (shortcut for --filter=binds).
			-w, --widgets filter by widget (shortcut for --filter=widgets).
			-h, --help show this help message.
		"
	_filter='binds'

	# Handle command-line arguments
	case "$1" in
	"-f" | "--filter") _filter=$2 ;;
	"-b" | "--binds") _filter="binds" ;;
	"-w" | "--widgets") _filter="widgets" ;;
	"-h" | "--help")
		echo "$_help"
		return 0
		;;
	*)
		[ -n "$1" ] && echo "Unknown option: $1" && echo "$_help" && return 1
		;;
	esac

	_keybinds_and_widgets=$(mktemp)

	# Populate the temporary file with keybinds and widgets
	bindkey | awk '{print $1 " " $2}' >"${_keybinds_and_widgets}"

	export _filter='"${_filter}"'
	export _filter_label='"$([[ "${_filter}" =~ "bind" ]] && echo "Keybind" || echo "Widget") for selected $(echo "${_filter}" | tr 'a-z' 'A-Z'):"'

	_selected=$(
		fzf \
			--bind "start:reload(awk '{print \$1 \" \" \$2}' <${_keybinds_and_widgets} | sort -k1)+change-preview-label(${_filter_label})" \
			--bind "ctrl-b:reload(awk '{print \$1 \" \" \$2}' <${_keybinds_and_widgets} | sort -k1)+change-preview-label(${_filter_label})" \
			--bind "ctrl-w:reload(awk '{print \$2 \" \" \$1}' <${_keybinds_and_widgets} | sort -k1)+change-preview-label(${_filter_label})" \
			--preview "grep --fixed-strings {2} ${_keybinds_and_widgets}" \
			--preview-window down:3:wrap \
			--preview-window 'right,border-top,<72(down,border-top)' \
			--preview-label="${_filter_label}" \
			--preview-label-pos '0:top'
	)

	/bin/rm "${_keybinds_and_widgets}"

	if [ -n "${_selected}" ]; then
		echo "Selected: ${_selected}"
	fi
}

# dedicated fzf function to abbreviate --preview for most common use cases:
function fzfp() {
	fzf \
		--preview \
		"$(
			if file --mime-type {} | grep image; then
				echo 'kitty icat --clear --transfer-mode=memory --stdin=no --place"=${FZF_PREVIEW_COLUMNS"}"x${FZF_PREVIEW_LINES"}@0x0 {} | sed \$d'
			else
				echo 'bat --color=always {}'
			fi
		)"
}

# The next two are used by fzf-cd-widget/fzf-insert-files to preview the directory contents. Doesn't work perfect, but it's a start.
# Look at src/fzf/shell/key-bindings.zsh and config/fzf/config for more info.
function eza_icon_strip() {
	! [[ $# -gt 0 ]] && return 0

	spaces=$(printf "%-${EZA_ICON_SPACING}s" "")
	echo "${1}" | awk --field-separator "${spaces}" '{print $NF}'
}

function eza_bat_preview() {
	! [[ $# -gt 0 ]] && return 0

	local fs_element
	fs_element=$(echo "${1}" | awk '{print $2}')

	if [[ -d "${fs_element}" ]]; then
		eza --all --tree --level 3 --long --oneline --color=always --icons always --git "${fs_element}"
	elif ! [[ $(file --mime-type ${fs_element}) =~ "binary" ]]; then
		bat --color=always "${fs_element}"
	else
		echo "Type: $(type "${fs_element}")"
	fi
}

# just some utilities to check existence quickly:
function isfile() {
	for __f_name in "$@"; do
		test -f "$__f_name" && echo "+++ $__f_name exists. +++" || echo "--- $__f_name does not exist. ---"
	done
}

function isdir() {
	for __dir_name in "$@"; do
		test -d "$__dir_name" && echo "+++ $__dir_name exists. +++" || echo "--- $__dir_name does not exist. ---"
	done
}

# I think I was making a widget that you could select 2 files with, and show a delta-diff between them...
# Not sure if it works correctly/ever did.
function fzf-delta() {
	fzf --multi=2 \
		--preview 'delta {+} --width=${FZF_PREVIEW_COLUMNS} || echo "Select 2 files using TAB"' \
		--preview-window '~3'
	# --preview "([ ! -s $temp_file ] && echo 'Select a file using TAB') || (diff -u $temp_file {} || true)"
}

# region conda fzf env act
### Conda environment activation:
# fzf-conda-activate() {
# 	choice=(
# 		$(
# 			conda env list |
# 				sed 's/\*/ /;1,2d' |
# 				xargs -I {} bash -c '
#                 name_path=( {} );
#                 py_version=( $(${name_path[1]}/bin/python --version) );
#                 echo ${name_path[0]} ${py_version[1]} ${name_path[1]}
#             ' |
# 				column -t |
# 				fzf --layout=reverse \
# 					--info=inline \
# 					--border=rounded \
# 					--height=40 \
# 					--preview-window="right:30%" \
# 					--preview-label=" conda tree leaves " \
# 					--preview=$'
#                     conda tree -p {3} leaves |
#                     perl -F\'[^\\w-_]\' -lae \'print for grep /./, @F;\' |
#                     sort
#                 '
# 		)
# 	)
# 	[[ -n "$choice" ]] && conda activate "$choice"
# }
# endregion conda fzf env act

# if you have conda, and you keep the alias 'condaa=conda activate',
# you can type 'condaa **<TAB>' and it will show you a list of conda environments and the packages installed in them.
### Conda environment activation:
function fzf-conda-activate() {
	choice=(
		"$(
			conda env list |
				sed 's/\*/ /;1,2d' |
				xargs -I {} bash -c '
                name_path=( {} );
                py_version=( $(${name_path[1]}/bin/python --version) );
                echo ${name_path[0]} ${py_version[1]}
            ' |
				column -t |
				fzf --info=inline \
					--border=rounded \
					--preview-window="right:50%" \
					--preview-label=" {1} packages " \
					--preview=$'
                    conda list -n {1} | sort
                '
		)"
	)
	[[ -z "$choice" ]] && return 0
	choice="$(echo ${choice} | awk {'print $1'})" || return 1
	echo "Activating conda environment: ${choice}"
	conda activate ${choice}
}

condaa() {
	if [[ $# -gt 0 ]]; then
		conda activate "$1"
	else
		zle
		fzf-conda-activate && return 0
	fi
}
_fzf_complete_condaa() {
	_fzf_complete --info=inline \
		--border=rounded \
		--preview-window="right:50%" \
		--preview-label=$' {1} packages ' \
		--preview=$'
                    conda list -n {1} | sort
                ' \
		--prompt="env >" -- "$@" < <(
			conda env list |
				sed 's/\*/ /;1,2d' |
				xargs -I {} bash -c '
				name_path=( {} );
				py_version=( $(${name_path[1]}/bin/python --version) );
				echo ${name_path[0]} ${py_version[1]}
			' |
				column -t
		)
}
_fzf_complete_condaa_post() {
	awk '{print $1}'
}

### Conda environment deactivation:
function condad() {
	cur=${COMP_WORDS[COMP_CWORD]}
	local help_
	help_="Doesn't really work right. WIP. \
	Usage:
		condad [-a|--all]

		-a, --all	Deactivate all conda environments. \

		With no options, deactivate the current conda environment."
	case "$1" in
	"")
		conda deactivate
		;;
	"-a" | "--all")
		while ${CONDA_SHLVL} -gt 0; do
			conda deactivate
		done
		;;
	"-h" | "--help")
		echo "${help_}"
		;;
	*)
		echo "Invalid option: $1"
		echo "${help_}"
		;;
	esac
}

function fman() {
	if [[ $# -eq 0 ]]; then
		zle
		fzf-man-widget
	else
		man $1
	fi
}

function fenv() {
	: | command='env' | fzf \
		--preview 'echo {} | cut -d'=' -f2 '
	#  \
	# 	--bind "enter:execute(echo {} | tr -d '\n' | pbcopy)"
}

# Pipe output to these to make them upper/lowercase:
function upper() {
	echo "$1" | tr '[:lower:]' '[:upper:]'
}

function lower() {
	echo "$1" | tr '[:upper:]' '[:lower:]'
}

# I don't think I've ever actually used this, wouldn't recommend.
function reset-path() {
	if [[ $# -eq 0 ]]; then
		echo "No variable name provided. Resetting PATH to DEFAULT_PATH $($DEFAULT_PATH | tr ':' '\n')."
		temp_env_var="DEFAULT_PATH"
	else
		echo "Resetting $1 to DEFAULT_PATH ($($DEFAULT_PATH | tr ':' '\n'))."
		temp_env_var=$1
	fi
	source "$HOME/.bash_profile"
	if [[ -z $temp_env_var ]]; then
		read -p "Either environment variable not specified or was not found. Exitting in 5sec..." -t 1
		echo
		for i in 5 4 3 2 1; do
			echo "Exiting in $i seconds..."
			sleep 1
		done
	fi
}

# same here:
function clean-path-var() {
	local search_string="python"
	local path_list="$PATH"

	if [[ $path_list != *"$search_string"* ]]; then
		if [[ -z $PATH ]]; then
			export PATH=$DEFAULT_PATH
		fi
		export PATH=$PATH:$PYTHON_PATH:$CONDA_PATH
	fi

	local input_var="$1"

	if [[ -z $input_var ]]; then
		input_var="PATH"
	fi
	python3 ~/clean_path_var.py -n "$input_var"
}

# makes a temp directory and opens it in vscode
function sandbox() {
	local tmpdir="$(mktemp -d -t sandbox-$(date +%Y-%m-%d-%H-%M-%S)-XXXXXX)"

	if [[ -z $tmpdir ]]; then
		echo "Failed to create temporary directory."
		return 1
	else
		echo "Created temporary directory: $tmpdir"
		cd "$tmpdir" || return 1
	fi
	code "$tmpdir"
}

# this one is handy, Ctrl-H or Ctrl-Backspace opens fzf with all the man pages you have.
# Then you can search them quickly:
if [[ -n $ZSH_VERSION ]]; then
	fzf-man-widget() {
		batman="man {1} | col -bx | \
		bat --language=man \
		--plain \
		--color always \
		--theme=\"Monokai Extended\"
		"
		man -k . | sort |
			awk -v cyan=$(tput setaf 6) -v blue=$(tput setaf 4) -v res=$(tput sgr0) -v bld=$(tput bold) '{ $1=cyan bld $1; $2=res blue;} 1' |
			fzf \
				-q "$1" \
				--ansi \
				--tiebreak=begin \
				--prompt=' Man > ' \
				--preview-window '50%,rounded,<50(up,85%,border-bottom)' \
				--preview "${batman}" \
				--bind "enter:execute(man {1})" \
				--bind "alt-c:+change-preview(cht.sh {1})+change-prompt(ﯽ Cheat > )" \
				--bind "alt-m:+change-preview(${batman})+change-prompt( Man > )" \
				--bind "alt-t:+change-preview(tldr {1})+change-prompt(ﳁ TLDR > )"
		zle reset-prompt
	}
	# `Ctrl-H` keybinding to launch the widget (this widget works only on zsh, don't know how to do it on bash and fish
	# (additionaly pressing`ctrl-backspace` will trigger the widget to be executed too because both share the same keycode)
	bindkey '^h' fzf-man-widget
	zle -N fzf-man-widget
	# Icon used is nerdfont
fi

# Strips the Unicode color codes from a string:
function get_color_code() {
	local str="$1"
	local hash=0
	for ((i = 0; i < ${#str}; i++)); do
		char="${str:$i:1}"
		ord=$(printf '%d' "'$char")
		hash=$(((hash * 31 + ord) % 7 + 31))
	done
	echo "$hash"
}

# Don't remember what this does, but it was probably useful at some point:
function cdd() {
	if [[ "$#" != 0 ]]; then
		builtin cd "$@"
		return
	fi

	while true; do
		local lsd=".."$'\n'"$(ls -pAFG --color=always | grep '/$' | sed 's;/$;;')"
		IFS=$'\n' read -d "${IFS}" -A dirArray <<<"${lsd}"

		# --bind='left:execute(cd ..)' --bind='right:execute(cd {})'
		local dir=$(
			for dir_entry in "${dirArray[@]}"; do
				color=$(get_color_code "${dir_entry}")
				printf $'\033['"%s"$'\033[0m\n' "${color}m${dir_entry}"
			done | fzf --reverse --preview '
				__cd_nxt=$(echo {});
				__cd_path="$(echo $(pwd)/${__cd_nxt} | sed "s;//;/;")";
				echo ${__cd_path};
				echo;
				ls -pAFG --color=always ${__cd_path};
			'
		)
		[[ ${#dir} != 0 ]] || return 0
		builtin cd "$dir" &>"/dev/null"
	done
}

# same here:
function lf() {
	if [[ "$#" != 0 ]]; then
		builtin ls -AFG "$@"
		return
	fi
	while true; do
		local lsd=$(echo ".." && ls -AFG | grep '/$' | sed 's;/$;;')
		local dir="$(printf '%s\n' "${lsd[@]}" |
			fzf --reverse --preview '
                __cd_nxt="$(echo {})";
                __cd_path="$(echo $(pwd)/${__cd_nxt} | sed "s;//;/;")";
                echo $__cd_path;
                echo;
				ls -lAF --color=always "${__cd_path}";
        ')"
		[[ ${#dir} != 0 ]] || return 0
		builtin cd "${dir}" &>"/dev/null" && builtin ls -lAF --color=always "${dir}"
	done
}

# The rest is kind of a graveyard of broken ideas/things I never finished/took out from lack of use.
# function show_colored() {
# 	echo "$@" | awk '/Package:|Version:/{print "\033[1;31m" $0 "\033[0m"; next} /Description:/{print "\033[1;32m" $0 "\033[0m"; next} {print}'
# }

# function fapt() {
# 	sudo apt -qq update
# 	"${HOME}/workstation_config/bin/pkgsearch.sh"
# 	# sudo apt -qq list --installed |
# 	# 	sed 's/\[installed.*\]//;s/\/.*//' |
# 	# 	sort >/tmp/apt-fzf-installed
# 	# sudo apt -qq list |
# 	# 	sed 's/\/.*//; /\[installed.*\]/d' |
# 	# 	sort >/tmp/apt-fzf-available

# 	# APT_AVAILABLE='cat /tmp/apt-fzf-available'
# 	# APT_INSTALLED='cat /tmp/apt-fzf-installed'

# 	# INITIAL_QUERY="${*:-}"
# 	# : | fzf --ansi --disabled --query "${INITIAL_QUERY}" \
# 	# 	--bind "start:reload(${APT_AVAILABLE})" \
# 	# 	--bind "alt-r:change-prompt( REMOVE > )+unbind(alt-r)+rebind(alt-i)+reload(${APT_INSTALLED})" \
# 	# 	--bind "alt-i:change-prompt(INSTALL > )+unbind(alt-i)+rebind(alt-r)+reload(${APT_AVAILABLE})" \
# 	# 	--prompt 'INSTALL >' \
# 	# 	--preview 'show_colored "$(apt show {})"' \
# 	# 	--preview-window 'right:50%' \
# 	# 	>'/tmp/apt-fzf-selections'

# 	# cat /tmp/apt-fzf-selections

# 	# /bin/rm -f /tmp/apt-fzf-{available, installed}
# }

# function cdh() {
# 	if [[ $# -gt 0 ]]; then
# 		cd "$1" || exit
# 	else
# 		cd "${HOME}" || exit
# 	fi
# }
# _fzf_complete_cdh() {
# 	_fzf_complete +m --reverse --border --ansi \
# 		--preview 'eza --all --tree --level=2 --color=always --icons {}' -- "$@" < <(
# 			dir -a -1 "${HOME}"
# 		)
# 	# fd --type=d --hidden --max-depth=1 --no-ignore --color=always . "${HOME}"
# }

# function cdwscfg() {
# 	if [[ $# -gt 0 ]]; then
# 		cd "$1" || exit
# 	else
# 		cd "${HOME}/workstation_config/" || exit
# 	fi
# 	conda deactivate
# }
# _fzf_complete_cdwscfg() {
# 	_fzf_complete +m --reverse --border --ansi \
# 		--preview 'eza --all --tree --level=2 --color=always --icons {}' -- "$@" < <(
# 			fd --type=d --hidden --max-depth=1 --no-ignore --color=always . "${HOME}/workstation_config/"
# 		)
# }
